// Generated by CU compiler
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

// CU Standard Library - Portable utilities
#include "cu_std.h"





typedef enum {
    OP_HALT,
    OP_PUSH,
    OP_POP,
    OP_ADD,
    OP_SUB,
    OP_MUL,
    OP_DIV,
    OP_PRINT,
    OP_JMP,
    OP_JMP_IF
} Opcode;

typedef struct {
    int32_t* stack;
    int32_t sp;
    int32_t stack_size;
    int32_t* code;
    int32_t ip;
    int32_t code_size;
    bool running;
} VM;

void vm_init(VM* vm, int32_t* code, int32_t code_size, int32_t stack_size) {
    (vm->code = code);
    (vm->code_size = code_size);
    (vm->ip = 0);
    (vm->stack_size = stack_size);
    (vm->stack = ((int32_t*)malloc((((uint64_t)stack_size) * 4))));
    (vm->sp = (-1));
    (vm->running = true);
    if ((vm->stack == NULL)) {
        printf("Failed to allocate VM stack!\n");
        exit(1);
    }
}

void vm_free(VM* vm) {
    free(vm->stack);
}

void push(VM* vm, int32_t value) {
    if ((vm->sp >= (vm->stack_size - 1))) {
        printf("Stack Overflow!\n");
        (vm->running = false);
        return;
    }
    (vm->stack[(++vm->sp)] = value);
}

int32_t pop(VM* vm) {
    if ((vm->sp < 0)) {
        printf("Stack Underflow!\n");
        (vm->running = false);
        return 0;
    }
    return vm->stack[(vm->sp--)];
}

void vm_run(VM* vm) {
    printf("--- VM Started ---\n");
    while (vm->running) {
        if ((vm->ip >= vm->code_size)) {
            printf("IP out of bounds!\n");
            break;
        }
        int32_t op = vm->code[(vm->ip++)];
        switch (op)         {
        case OP_HALT:
            printf("HALT\n");
            (vm->running = false);
            break;
        case OP_PUSH:
            {
                int32_t val = vm->code[(vm->ip++)];
                push(vm, val);
                break;
            }
        case OP_POP:
            pop(vm);
            break;
        case OP_ADD:
            {
                int32_t b = pop(vm);
                int32_t a = pop(vm);
                push(vm, (a + b));
                break;
            }
        case OP_SUB:
            {
                int32_t b = pop(vm);
                int32_t a = pop(vm);
                push(vm, (a - b));
                break;
            }
        case OP_MUL:
            {
                int32_t b = pop(vm);
                int32_t a = pop(vm);
                push(vm, (a * b));
                break;
            }
        case OP_DIV:
            {
                int32_t b = pop(vm);
                int32_t a = pop(vm);
                if ((b == 0)) {
                    printf("Runtime Error: Division by zero in VM!\n");
                    (vm->running = false);
                } else {
                    push(vm, ((CU_CHECK_DIV_ZERO(b, "examples/vm_demo.cup", 1), a / b)));
                }
                break;
            }
        case OP_PRINT:
            {
                int32_t val = pop(vm);
                printf("OUT: %d\n", val);
                break;
            }
        case OP_JMP:
            {
                int32_t header = vm->code[(vm->ip++)];
                (vm->ip = header);
                break;
            }
        case OP_JMP_IF:
            {
                int32_t addr = vm->code[(vm->ip++)];
                int32_t cond = pop(vm);
                if ((cond != 0)) {
                    (vm->ip = addr);
                }
                break;
            }
        default:
            printf("Unknown Opcode: %d at IP %d\n", op, (vm->ip - 1));
            (vm->running = false);
            break;
        }
    }
    printf("--- VM Stopped ---\n");
}

int32_t main(void) {
    int32_t program[20] = {OP_PUSH, 10, OP_PUSH, 20, OP_ADD, OP_PUSH, 5, OP_DIV, OP_PRINT, OP_HALT};
    VM vm;
    vm_init((&vm), program, 20, 128);
    vm_run((&vm));
    vm_free((&vm));
    int32_t asm_test = 0;
    return 0;
}

