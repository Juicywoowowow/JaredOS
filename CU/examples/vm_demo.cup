import fn printf(const i8* fmt, ...) -> i32;
import fn malloc(u64 size) -> void*;
import fn free(void* p) -> void;
import fn exit(i32 status) -> void;

// Instruction Set
enum Opcode {
    OP_HALT,    // 0
    OP_PUSH,    // 1 <val>
    OP_POP,     // 2
    OP_ADD,     // 3
    OP_SUB,     // 4
    OP_MUL,     // 5
    OP_DIV,     // 6
    OP_PRINT,   // 7
    OP_JMP,     // 8 <addr>
    OP_JMP_IF   // 9 <addr> (pop and jump if true/non-zero)
}

// VM State
struct VM {
    i32* stack;
    i32 sp;         // Stack pointer
    i32 stack_size;
    
    i32* code;
    i32 ip;         // Instruction pointer
    i32 code_size;
    
    bool running;
}

// Initialize VM
fn vm_init(VM* vm, i32* code, i32 code_size, i32 stack_size) -> void {
    vm->code = code;
    vm->code_size = code_size;
    vm->ip = 0;
    
    vm->stack_size = stack_size;
    vm->stack = cast(i32*) malloc(cast(u64)stack_size * 4); // 4 bytes per i32
    vm->sp = -1;
    
    vm->running = true;
    
    // Check if allocation failed (will trigger null trap if we use it, but good to be explicit)
    if (vm->stack == null) {
        printf("Failed to allocate VM stack!\n");
        exit(1);
    }
}

// Cleanup VM
fn vm_free(VM* vm) -> void {
    free(vm->stack);
}

// Stack Operations
fn push(VM* vm, i32 value) -> void {
    if (vm->sp >= vm->stack_size - 1) {
        printf("Stack Overflow!\n");
        vm->running = false;
        return;
    }
    vm->stack[++vm->sp] = value;
}

fn pop(VM* vm) -> i32 {
    if (vm->sp < 0) {
        printf("Stack Underflow!\n");
        vm->running = false;
        return 0;
    }
    return vm->stack[vm->sp--];
}

// Main Fetch-Decode-Execute Loop
fn vm_run(VM* vm) -> void {
    printf("--- VM Started ---\n");
    
    while (vm->running) {
        if (vm->ip >= vm->code_size) {
            printf("IP out of bounds!\n");
            break;
        }
        
        // Fetch
        i32 op = vm->code[vm->ip++];
        
        // Decode & Execute
        switch (op) {
            case OP_HALT:
                printf("HALT\n");
                vm->running = false;
                break;
                
            case OP_PUSH: {
                i32 val = vm->code[vm->ip++];
                // printf("PUSH %d\n", val);
                push(vm, val);
                break;
            }
                
            case OP_POP:
                pop(vm);
                break;
                
            case OP_ADD: {
                i32 b = pop(vm);
                i32 a = pop(vm);
                push(vm, a + b);
                break;
            }
                
            case OP_SUB: {
                i32 b = pop(vm);
                i32 a = pop(vm);
                push(vm, a - b);
                break;
            }
                
            case OP_MUL: {
                i32 b = pop(vm);
                i32 a = pop(vm);
                push(vm, a * b);
                break;
            }
                
            case OP_DIV: {
                i32 b = pop(vm);
                i32 a = pop(vm);
                // Safety: Division by zero is now trapped by compiler too!
                if (b == 0) {
                    printf("Runtime Error: Division by zero in VM!\n");
                    vm->running = false;
                } else {
                    push(vm, a / b);
                }
                break;
            }
            
            case OP_PRINT: {
                i32 val = pop(vm);
                printf("OUT: %d\n", val);
                break;
            }
            
            case OP_JMP: {
                i32 header = vm->code[vm->ip++];
                vm->ip = header;
                break;
            }
            
            case OP_JMP_IF: {
                i32 addr = vm->code[vm->ip++];
                i32 cond = pop(vm);
                if (cond != 0) {
                    vm->ip = addr;
                }
                break;
            }
                
            default:
                printf("Unknown Opcode: %d at IP %d\n", op, vm->ip - 1);
                vm->running = false;
                break;
        }
    }
    
    printf("--- VM Stopped ---\n");
}

fn main() -> i32 {
    // Defines a program:
    // PUSH 10
    // PUSH 20
    // ADD      (stack: 30)
    // PUSH 5
    // DIV      (stack: 6)
    // OP_PRINT
    // HALT
    
    i32[20] program = {
        OP_PUSH, 10,
        OP_PUSH, 20,
        OP_ADD,
        OP_PUSH, 5,
        OP_DIV,
        OP_PRINT,
        OP_HALT
    };
    
    VM vm;
    vm_init(&vm, program, 20, 128);
    
    vm_run(&vm);
    
    vm_free(&vm);
    
    // Demonstrate inline assembly usage again just to be comprehensive
    i32 asm_test = 0;
    // Simple NOP or move using inline asm (platform agnostic-ish NOP)
    // asm("nop"); 
    
    return 0;
}
