#include "codegen.hpp"
#include <unordered_set>

namespace {
// Functions defined inline in cu_std.h - skip extern declarations for these
const std::unordered_set<std::string> cu_std_functions = {
    "cu_bswap16", "cu_bswap32", "cu_bswap64",
    "cu_be16", "cu_be32", "cu_be64",
    "cu_le16", "cu_le32", "cu_le64",
    "cu_memcpy", "cu_memset", "cu_memcmp",
    "cu_strlen", "cu_strcmp", "cu_strcpy", "cu_strcat",
    "cu_is_aligned", "cu_align_up", "cu_align_down",
    "cu_abs_i32", "cu_abs_i64",
    "cu_min_i32", "cu_max_i32", "cu_min_u32", "cu_max_u32",
    "cu_popcount32", "cu_clz32", "cu_ctz32",
    "cu_get_platform_info",
    // Standard library functions included via cu_std.h
    "printf", "malloc", "free", "calloc", "realloc", "puts", "exit", "abort"
};
} // anonymous namespace

namespace cu {

void CodeGen::emit(const std::string& s) {
    out_ << s;
}

void CodeGen::emit_line(const std::string& s) {
    emit_indent();
    out_ << s << "\n";
}

void CodeGen::emit_indent() {
    for (int i = 0; i < indent_; i++) out_ << "    ";
}

void CodeGen::inc_indent() { indent_++; }
void CodeGen::dec_indent() { indent_--; }

std::string CodeGen::generate(const TranslationUnit& unit) {
    out_.str("");
    out_.clear();
    source_file_ = unit.filename;
    
    // Header
    emit_line("// Generated by CU compiler");
    emit_line("#include <stdint.h>");
    emit_line("#include <stdbool.h>");
    emit_line("#include <stddef.h>");
    emit_line("");
    emit_line("// CU Standard Library - Portable utilities");
    emit_line("#include \"cu_std.h\"");
    emit_line("");
    
    // Emit declarations
    for (const auto& decl : unit.declarations) {
        emit_decl(*decl);
        emit("\n");
    }
    
    return out_.str();
}

void CodeGen::emit_decl(const Decl& decl) {
    switch (decl.kind) {
        case Decl::FUNCTION: emit_function(decl); break;
        case Decl::STRUCT: emit_struct(decl); break;
        case Decl::UNION: emit_union(decl); break;
        case Decl::ENUM: emit_enum(decl); break;
        case Decl::TYPEDEF: emit_typedef(decl); break;
        case Decl::IMPORT: emit_import(decl); break;
    }
}

void CodeGen::emit_import(const Decl& decl) {
    // Skip extern declaration for cu_std.h functions (they're inline/macros)
    if (cu_std_functions.count(decl.name)) {
        return;
    }
    
    emit_indent();
    emit("extern ");
    emit(type_to_c(*decl.return_type));
    emit(" ");
    emit(decl.name);
    emit("(");
    for (size_t i = 0; i < decl.params.size(); i++) {
        if (i > 0) emit(", ");
        emit(type_for_decl(decl.params[i].second, decl.params[i].first));
    }
    if (decl.is_variadic) {
        if (!decl.params.empty()) emit(", ");
        emit("...");
    }
    if (decl.params.empty() && !decl.is_variadic) emit("void");
    emit(");\n");
}

void CodeGen::emit_function(const Decl& decl) {
    if (decl.is_inline) emit_line("static inline");
    
    emit_indent();
    emit(type_to_c(*decl.return_type));
    emit(" ");
    emit(decl.name);
    emit("(");
    for (size_t i = 0; i < decl.params.size(); i++) {
        if (i > 0) emit(", ");
        emit(type_for_decl(decl.params[i].second, decl.params[i].first));
    }
    if (decl.params.empty()) emit("void");
    emit(")");
    
    if (decl.body.empty() && decl.is_extern) {
        emit(";\n");
        return;
    }
    
    emit(" {\n");
    inc_indent();
    for (const auto& stmt : decl.body) {
        emit_stmt(*stmt);
    }
    dec_indent();
    emit_line("}");
}

void CodeGen::emit_struct(const Decl& decl) {
    if (decl.is_packed) emit_line("#pragma pack(push, 1)");
    
    emit_indent();
    if (decl.align > 0) {
        emit("__attribute__((aligned(" + std::to_string(decl.align) + "))) ");
    }
    emit("typedef struct {\n");
    inc_indent();
    for (const auto& field : decl.fields) {
        emit_line(type_for_decl(field.second, field.first) + ";");
    }
    dec_indent();
    emit_line("} " + decl.name + ";");
    
    if (decl.is_packed) emit_line("#pragma pack(pop)");
}

void CodeGen::emit_union(const Decl& decl) {
    emit_line("typedef union {");
    inc_indent();
    for (const auto& field : decl.fields) {
        emit_line(type_for_decl(field.second, field.first) + ";");
    }
    dec_indent();
    emit_line("} " + decl.name + ";");
}

void CodeGen::emit_enum(const Decl& decl) {
    emit_line("typedef enum {");
    inc_indent();
    for (size_t i = 0; i < decl.enum_values.size(); i++) {
        const auto& ev = decl.enum_values[i];
        emit_indent();
        emit(ev.first);
        if (ev.second) {
            emit(" = " + std::to_string(*ev.second));
        }
        if (i + 1 < decl.enum_values.size()) emit(",");
        emit("\n");
    }
    dec_indent();
    emit_line("} " + decl.name + ";");
}

void CodeGen::emit_typedef(const Decl& decl) {
    emit_line("typedef " + type_to_c(*decl.aliased_type) + " " + decl.name + ";");
}

void CodeGen::emit_stmt(const Stmt& stmt) {
    switch (stmt.kind) {
        case Stmt::EXPR:
            emit_indent();
            emit_expr(*stmt.expr);
            emit(";\n");
            break;
            
        case Stmt::BLOCK:
            emit_block(stmt);
            break;

        case Stmt::ASM:
            emit_indent();
            // Use __asm__ for compatibility
            emit("__asm__(" + stmt.asm_string + ");\n");
            break;
            
        case Stmt::SWITCH:
            emit_indent();
            emit("switch (");
            emit_expr(*stmt.condition);
            emit(") ");
            if (stmt.body->kind == Stmt::BLOCK) {
                emit_block(*stmt.body);
            } else {
                emit("\n");
                inc_indent();
                emit_stmt(*stmt.body);
                dec_indent();
            }
            break;
            
        case Stmt::CASE:
            // Dedent slightly to align with switch/braces if desired, 
            // but standard C formatters often indent cases. 
            // We'll just stick to current indentation level.
            // If inside a block, we are already indented.
            // Some styles put cases at same level as switch, but inside braces they are usually indented.
            // Let's just emit at current indent.
            dec_indent(); // Optional: Makes it look like standard K&R/1TBS if inside braces
            emit_indent();
            emit("case ");
            emit_expr(*stmt.case_value);
            emit(":\n");
            inc_indent();
            break;
            
        case Stmt::DEFAULT:
            dec_indent();
            emit_indent();
            emit("default:\n");
            inc_indent();
            break;
            
        case Stmt::DO_WHILE:
            emit_indent();
            emit("do ");
            if (stmt.body->kind == Stmt::BLOCK) {
                // emit_block emits { ... } with newline
                emit_block(*stmt.body);
                // We are now on a new line
                emit_indent(); // Match indentation of 'do'
            } else {
                emit("\n");
                inc_indent();
                emit_stmt(*stmt.body);
                dec_indent();
                emit_indent();
            }
            emit("while (");
            emit_expr(*stmt.condition);
            emit(");\n");
            break;
            
        case Stmt::IF:
            emit_indent();
            emit("if (");
            emit_expr(*stmt.condition);
            emit(") ");
            if (stmt.then_stmt->kind == Stmt::BLOCK) {
                emit("{\n");
                inc_indent();
                for (const auto& s : stmt.then_stmt->statements) emit_stmt(*s);
                dec_indent();
                emit_indent();
                emit("}");
            } else {
                emit("\n");
                inc_indent();
                emit_stmt(*stmt.then_stmt);
                dec_indent();
            }
            if (stmt.else_stmt) {
                emit(" else ");
                if (stmt.else_stmt->kind == Stmt::BLOCK) {
                    emit("{\n");
                    inc_indent();
                    for (const auto& s : stmt.else_stmt->statements) emit_stmt(*s);
                    dec_indent();
                    emit_line("}");
                } else if (stmt.else_stmt->kind == Stmt::IF) {
                    emit("\n");
                    emit_stmt(*stmt.else_stmt);
                } else {
                    emit("\n");
                    inc_indent();
                    emit_stmt(*stmt.else_stmt);
                    dec_indent();
                }
            } else {
                emit("\n");
            }
            break;
            
        case Stmt::WHILE:
            emit_indent();
            emit("while (");
            emit_expr(*stmt.condition);
            emit(") ");
            if (stmt.body->kind == Stmt::BLOCK) {
                emit("{\n");
                inc_indent();
                for (const auto& s : stmt.body->statements) emit_stmt(*s);
                dec_indent();
                emit_line("}");
            } else {
                emit("\n");
                inc_indent();
                emit_stmt(*stmt.body);
                dec_indent();
            }
            break;
            
        case Stmt::FOR:
            emit_indent();
            emit("for (");
            if (stmt.init) {
                if (stmt.init->kind == Stmt::VAR_DECL) {
                    emit(type_for_decl(*stmt.init->var_type, stmt.init->var_name));
                    if (stmt.init->var_init) {
                        emit(" = ");
                        emit_expr(*stmt.init->var_init);
                    }
                } else if (stmt.init->expr) {
                    emit_expr(*stmt.init->expr);
                }
            }
            emit("; ");
            if (stmt.condition) emit_expr(*stmt.condition);
            emit("; ");
            if (stmt.post) emit_expr(*stmt.post);
            emit(") ");
            if (stmt.body->kind == Stmt::BLOCK) {
                emit("{\n");
                inc_indent();
                for (const auto& s : stmt.body->statements) emit_stmt(*s);
                dec_indent();
                emit_line("}");
            } else {
                emit("\n");
                inc_indent();
                emit_stmt(*stmt.body);
                dec_indent();
            }
            break;
            
        case Stmt::RETURN:
            emit_indent();
            emit("return");
            if (stmt.expr) {
                emit(" ");
                emit_expr(*stmt.expr);
            }
            emit(";\n");
            break;
            
        case Stmt::BREAK:
            emit_line("break;");
            break;
            
        case Stmt::CONTINUE:
            emit_line("continue;");
            break;
            
        case Stmt::GOTO:
            emit_line("goto " + stmt.label + ";");
            break;
            
        case Stmt::LABEL:
            dec_indent();
            emit_line(stmt.label + ":");
            inc_indent();
            break;
            
        case Stmt::VAR_DECL:
            emit_indent();
            if (stmt.is_static) emit("static ");
            if (stmt.is_const) emit("const ");
            emit(type_for_decl(*stmt.var_type, stmt.var_name));
            if (stmt.var_init) {
                emit(" = ");
                emit_expr(*stmt.var_init);
            }
            emit(";\n");
            break;
    }
}

void CodeGen::emit_block(const Stmt& stmt) {
    emit_line("{");
    inc_indent();
    for (const auto& s : stmt.statements) {
        emit_stmt(*s);
    }
    dec_indent();
    emit_line("}");
}

void CodeGen::emit_expr(const Expr& expr) {
    switch (expr.kind) {
        case Expr::INTEGER_LIT:
            emit(std::to_string(expr.int_value));
            break;
            
        case Expr::FLOAT_LIT:
            emit(std::to_string(expr.float_value));
            break;
            
        case Expr::STRING_LIT:
            emit("\"");
            for (char c : expr.string_value) {
                switch (c) {
                    case '\n': emit("\\n"); break;
                    case '\t': emit("\\t"); break;
                    case '\r': emit("\\r"); break;
                    case '\0': emit("\\0"); break;
                    case '\\': emit("\\\\"); break;
                    case '"': emit("\\\""); break;
                    default: emit(std::string(1, c));
                }
            }
            emit("\"");
            break;
            
        case Expr::CHAR_LIT:
            emit("'");
            if (expr.string_value.empty()) {
                emit("\\0");
            } else {
                char c = expr.string_value[0];
                switch (c) {
                    case '\n': emit("\\n"); break;
                    case '\t': emit("\\t"); break;
                    case '\r': emit("\\r"); break;
                    case '\0': emit("\\0"); break;
                    case '\\': emit("\\\\"); break;
                    case '\'': emit("\\'"); break;
                    default: emit(std::string(1, c));
                }
            }
            emit("'");
            break;
            
        case Expr::BOOL_LIT:
            emit(expr.bool_value ? "true" : "false");
            break;
            
        case Expr::NULL_LIT:
            emit("NULL");
            break;
            
        case Expr::IDENTIFIER:
            emit(expr.string_value);
            break;
            
        case Expr::BINARY: {
            // Check for division by zero
            if (expr.op == "/" || expr.op == "%") {
                // Capture right side for check
                std::stringstream right_str;
                std::swap(out_, right_str);
                emit_expr(*expr.right);
                std::swap(out_, right_str);
                std::string right_expr = right_str.str();
                
                emit("(");
                // Note: Division check happens at runtime via the generated code
                emit("(CU_CHECK_DIV_ZERO(" + right_expr + ", \"" + source_file_ + "\", " + std::to_string(expr.loc.line) + "), ");
                emit_expr(*expr.left);
                emit(" " + expr.op + " " + right_expr + "))");
            } else {
                emit("(");
                emit_expr(*expr.left);
                emit(" " + expr.op + " ");
                emit_expr(*expr.right);
                emit(")");
            }
            break;
        }
            
        case Expr::UNARY:
            if (expr.op.find("_post") != std::string::npos) {
                emit("(");
                emit_expr(*expr.operand);
                emit(expr.op.substr(0, 2));
                emit(")");
            } else if (expr.op == "*") {
                // Pointer dereference - add null check using compound statement (GCC extension)
                std::stringstream ptr_str;
                std::swap(out_, ptr_str);
                emit_expr(*expr.operand);
                std::swap(out_, ptr_str);
                std::string ptr_expr = ptr_str.str();
                
                // Use ({ }) compound statement that yields lvalue for the dereferenced pointer
                emit("(*({ CU_CHECK_NULL(" + ptr_expr + ", \"" + source_file_ + "\", " + std::to_string(expr.loc.line) + "); " + ptr_expr + "; }))");
            } else {
                emit("(" + expr.op);
                emit_expr(*expr.operand);
                emit(")");
            }
            break;
            
        case Expr::CALL:
            emit_expr(*expr.left);
            emit("(");
            for (size_t i = 0; i < expr.args.size(); i++) {
                if (i > 0) emit(", ");
                emit_expr(*expr.args[i]);
            }
            emit(")");
            break;
            
        case Expr::INDEX:
            emit_expr(*expr.left);
            emit("[");
            emit_expr(*expr.right);
            emit("]");
            break;
            
        case Expr::MEMBER:
            emit_expr(*expr.left);
            emit(expr.op == "->" ? "->" : ".");
            emit(expr.string_value);
            break;
            
        case Expr::CAST:
            emit("((" + type_to_c(*expr.cast_type) + ")");
            emit_expr(*expr.operand);
            emit(")");
            break;
            
        case Expr::SIZEOF:
            emit("sizeof(" + type_to_c(*expr.cast_type) + ")");
            break;
            
        case Expr::TERNARY:
            emit("(");
            emit_expr(*expr.condition);
            emit(" ? ");
            emit_expr(*expr.then_expr);
            emit(" : ");
            emit_expr(*expr.else_expr);
            emit(")");
            break;
            
        case Expr::INIT_LIST:
            emit("{");
            for (size_t i = 0; i < expr.elements.size(); i++) {
                if (i > 0) emit(", ");
                emit_expr(*expr.elements[i]);
            }
            emit("}");
            break;
    }
}

std::string CodeGen::type_to_c(const Type& type) {
    std::string result;
    
    // Add const qualifier if present
    if (type.is_const) {
        result = "const ";
    }
    
    switch (type.kind) {
        case Type::VOID: result += "void"; break;
        case Type::BOOL: result += "bool"; break;
        case Type::I8: result += "char"; break;  // Use char for C string compatibility
        case Type::I16: result += "int16_t"; break;
        case Type::I32: result += "int32_t"; break;
        case Type::I64: result += "int64_t"; break;
        case Type::U8: result += "uint8_t"; break;
        case Type::U16: result += "uint16_t"; break;
        case Type::U32: result += "uint32_t"; break;
        case Type::U64: result += "uint64_t"; break;
        case Type::F32: result += "float"; break;
        case Type::F64: result += "double"; break;
        case Type::PTR: result += "void*"; break;
        case Type::POINTER:
            result += type_to_c(*type.pointee) + "*";
            break;
        case Type::ARRAY:
            result += type_to_c(*type.element);
            break;
        case Type::NAMED:
            result += type.name;
            break;
        case Type::FUNCTION:
            result += type_to_c(*type.return_type) + "(*)()";
            break;
        default:
            result += "void";
            break;
    }
    
    return result;
}

std::string CodeGen::type_for_decl(const Type& type, const std::string& name) {
    if (type.kind == Type::ARRAY) {
        if (type.array_size > 0) {
            return type_to_c(*type.element) + " " + name + "[" + std::to_string(type.array_size) + "]";
        } else {
            return type_to_c(*type.element) + "* " + name;
        }
    }
    if (type.kind == Type::FUNCTION) {
        std::string result = type_to_c(*type.return_type) + " (*" + name + ")(";
        for (size_t i = 0; i < type.params.size(); i++) {
            if (i > 0) result += ", ";
            result += type_to_c(type.params[i]);
        }
        result += ")";
        return result;
    }
    return type_to_c(type) + " " + name;
}

void CodeGen::emit_null_check(const std::string& ptr_expr, int line) {
    emit_line("CU_CHECK_NULL(" + ptr_expr + ", \"" + source_file_ + "\", " + std::to_string(line) + ");");
}

void CodeGen::emit_div_check(const std::string& divisor_expr, int line) {
    emit_line("CU_CHECK_DIV_ZERO(" + divisor_expr + ", \"" + source_file_ + "\", " + std::to_string(line) + ");");
}

} // namespace cu
