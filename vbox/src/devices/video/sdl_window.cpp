/*
 * VBox - Simple x86 Emulator
 * SDL2 Display Window (C++ with Smart Pointers)
 */

#include "vbox/display.hpp"
#include <cstring>

#ifdef __cplusplus

/*============================================================================
 * VGA Font (8x16 bitmap font for text mode)
 * This is a simplified 8x8 font - in production use a proper VGA ROM font
 *============================================================================*/

// Very basic 8x8 font for printable ASCII characters
static const uint8_t font_8x8[128][8] = {
    // 0-31: Control characters (blank)
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0},

    // 32: Space
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 33: !
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00},
    // 34: "
    {0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 35: #
    {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00},
    // 36: $
    {0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00},
    // 37: %
    {0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00},
    // 38: &
    {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00},
    // 39: '
    {0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 40: (
    {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00},
    // 41: )
    {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00},
    // 42: *
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},
    // 43: +
    {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00},
    // 44: ,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30},
    // 45: -
    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00},
    // 46: .
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},
    // 47: /
    {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00},
    // 48-57: 0-9
    {0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00}, // 0
    {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // 1
    {0x3C, 0x66, 0x06, 0x1C, 0x30, 0x60, 0x7E, 0x00}, // 2
    {0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00}, // 3
    {0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00}, // 4
    {0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00}, // 5
    {0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00}, // 6
    {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    {0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00}, // 8
    {0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00}, // 9
    // 58: :
    {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00},
    // 59: ;
    {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00},
    // 60: <
    {0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00},
    // 61: =
    {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00},
    // 62: >
    {0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00},
    // 63: ?
    {0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00},
    // 64: @
    {0x3C, 0x66, 0x6E, 0x6A, 0x6E, 0x60, 0x3C, 0x00},
    // 65-90: A-Z
    {0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00}, // A
    {0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00}, // B
    {0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00}, // C
    {0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00}, // D
    {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00}, // E
    {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00}, // F
    {0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3E, 0x00}, // G
    {0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}, // H
    {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // I
    {0x3E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00}, // J
    {0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00}, // K
    {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00}, // L
    {0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00}, // M
    {0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00}, // N
    {0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}, // O
    {0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00}, // P
    {0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00}, // Q
    {0x7C, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00}, // R
    {0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00}, // S
    {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, // T
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}, // U
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}, // V
    {0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00}, // W
    {0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00}, // X
    {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00}, // Y
    {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00}, // Z
    // 91: [
    {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00},
    // 92: backslash
    {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00},
    // 93: ]
    {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00},
    // 94: ^
    {0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 95: _
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00},
    // 96: `
    {0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 97-122: a-z
    {0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00}, // a
    {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00}, // b
    {0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00}, // c
    {0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00}, // d
    {0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00}, // e
    {0x1C, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x30, 0x00}, // f
    {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C}, // g
    {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}, // h
    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}, // i
    {0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38}, // j
    {0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00}, // k
    {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // l
    {0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00}, // m
    {0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}, // n
    {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00}, // o
    {0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60}, // p
    {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06}, // q
    {0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00}, // r
    {0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00}, // s
    {0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x1C, 0x00}, // t
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00}, // u
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}, // v
    {0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00}, // w
    {0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00}, // x
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C}, // y
    {0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00}, // z
    // 123: {
    {0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00},
    // 124: |
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00},
    // 125: }
    {0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00},
    // 126: ~
    {0x00, 0x00, 0x60, 0x92, 0x0C, 0x00, 0x00, 0x00},
    // 127: DEL
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
};

/*============================================================================
 * VGA Color Palette (16 standard CGA colors)
 *============================================================================*/

static const uint32_t vga_palette[16] = {
    0xFF000000, // 0: Black
    0xFF0000AA, // 1: Blue
    0xFF00AA00, // 2: Green
    0xFF00AAAA, // 3: Cyan
    0xFFAA0000, // 4: Red
    0xFFAA00AA, // 5: Magenta
    0xFFAA5500, // 6: Brown
    0xFFAAAAAA, // 7: Light Gray
    0xFF555555, // 8: Dark Gray
    0xFF5555FF, // 9: Light Blue
    0xFF55FF55, // 10: Light Green
    0xFF55FFFF, // 11: Light Cyan
    0xFFFF5555, // 12: Light Red
    0xFFFF55FF, // 13: Light Magenta
    0xFFFFFF55, // 14: Yellow
    0xFFFFFFFF, // 15: White
};

/*============================================================================
 * VBoxDisplay Implementation
 *============================================================================*/

VBoxDisplay::VBoxDisplay(const char *title, int width, int height, int scale)
    : window_(nullptr, SDL_DestroyWindow),
      renderer_(nullptr, SDL_DestroyRenderer),
      framebuffer_(nullptr, SDL_DestroyTexture), width_(width), height_(height),
      scale_(scale) {
  // Initialize SDL if not already done
  if (SDL_WasInit(SDL_INIT_VIDEO) == 0) {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
      return;
    }
  }

  // Create window
  SDL_Window *win =
      SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                       width * scale, height * scale, SDL_WINDOW_SHOWN);
  if (!win)
    return;
  window_.reset(win);

  // Create renderer
  SDL_Renderer *ren = SDL_CreateRenderer(
      win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
  if (!ren) {
    window_.reset();
    return;
  }
  renderer_.reset(ren);

  // Set logical size for automatic scaling
  SDL_RenderSetLogicalSize(ren, width, height);

  // Create framebuffer texture
  SDL_Texture *tex =
      SDL_CreateTexture(ren, SDL_PIXELFORMAT_ARGB8888,
                        SDL_TEXTUREACCESS_STREAMING, width, height);
  if (!tex) {
    renderer_.reset();
    window_.reset();
    return;
  }
  framebuffer_.reset(tex);

  // Allocate text buffer
  text_buffer_ = std::make_unique<uint32_t[]>(width * height);
  std::memset(text_buffer_.get(), 0, width * height * sizeof(uint32_t));
}

VBoxDisplay::~VBoxDisplay() {
  // Smart pointers handle cleanup automatically
  // Just quit SDL if we were the ones who initialized it
}

void VBoxDisplay::render_text_char(int x, int y, uint8_t ch, uint8_t attr) {
  if (ch > 127)
    ch = '?'; // Clamp to ASCII

  uint32_t fg_color = vga_palette[attr & 0x0F];
  uint32_t bg_color = vga_palette[(attr >> 4) & 0x0F];

  const uint8_t *glyph = font_8x8[ch];

  // Each character is 8x8 pixels
  int base_x = x * 8;
  int base_y = y * 8;

  for (int row = 0; row < 8; row++) {
    uint8_t bits = glyph[row];
    for (int col = 0; col < 8; col++) {
      int px = base_x + col;
      int py = base_y + row;
      if (px < width_ && py < height_) {
        text_buffer_[py * width_ + px] =
            (bits & (0x80 >> col)) ? fg_color : bg_color;
      }
    }
  }
}

void VBoxDisplay::update_text_mode(const uint8_t *vga_memory, int cols,
                                   int rows) {
  for (int y = 0; y < rows && y * 8 < height_; y++) {
    for (int x = 0; x < cols && x * 8 < width_; x++) {
      int offset = (y * cols + x) * 2;
      uint8_t ch = vga_memory[offset];
      uint8_t attr = vga_memory[offset + 1];
      render_text_char(x, y, ch, attr);
    }
  }

  // Update texture
  SDL_UpdateTexture(framebuffer_.get(), nullptr, text_buffer_.get(),
                    width_ * sizeof(uint32_t));
}

void VBoxDisplay::update_framebuffer(const uint32_t *pixels, int pitch) {
  SDL_UpdateTexture(framebuffer_.get(), nullptr, pixels, pitch);
}

bool VBoxDisplay::poll_events(uint8_t *key_pressed, uint8_t *scancode) {
  SDL_Event event;
  *key_pressed = 0;
  *scancode = 0;

  while (SDL_PollEvent(&event)) {
    switch (event.type) {
    case SDL_QUIT:
      return false;

    case SDL_KEYDOWN: {
      SDL_Keycode key = event.key.keysym.sym;
      *scancode = event.key.keysym.scancode;

      // Convert SDL keycode to ASCII
      if (key >= SDLK_a && key <= SDLK_z) {
        *key_pressed = (event.key.keysym.mod & KMOD_SHIFT)
                           ? (key - SDLK_a + 'A')
                           : (key - SDLK_a + 'a');
      } else if (key >= SDLK_0 && key <= SDLK_9) {
        *key_pressed = key - SDLK_0 + '0';
      } else if (key == SDLK_SPACE) {
        *key_pressed = ' ';
      } else if (key == SDLK_RETURN) {
        *key_pressed = '\r';
      } else if (key == SDLK_BACKSPACE) {
        *key_pressed = '\b';
      } else if (key == SDLK_ESCAPE) {
        *key_pressed = 0x1B;
      }
      break;
    }
    }
  }

  return true;
}

void VBoxDisplay::present() {
  SDL_RenderClear(renderer_.get());
  SDL_RenderCopy(renderer_.get(), framebuffer_.get(), nullptr, nullptr);
  SDL_RenderPresent(renderer_.get());
}

void VBoxDisplay::clear() {
  std::memset(text_buffer_.get(), 0, width_ * height_ * sizeof(uint32_t));
  SDL_UpdateTexture(framebuffer_.get(), nullptr, text_buffer_.get(),
                    width_ * sizeof(uint32_t));
}

#endif /* __cplusplus */

/*============================================================================
 * C Interface Implementation
 *============================================================================*/

extern "C" {

VBoxDisplay *display_create(const char *title, int width, int height,
                            int scale) {
  auto *display = new (std::nothrow) VBoxDisplay(title, width, height, scale);
  if (display && !display->is_valid()) {
    delete display;
    return nullptr;
  }
  return display;
}

void display_destroy(VBoxDisplay *display) { delete display; }

void display_update_text(VBoxDisplay *display, const uint8_t *vga_memory,
                         int cols, int rows) {
  if (display) {
    display->update_text_mode(vga_memory, cols, rows);
  }
}

int display_poll(VBoxDisplay *display, uint8_t *key_pressed,
                 uint8_t *scancode) {
  if (display) {
    return display->poll_events(key_pressed, scancode) ? 1 : 0;
  }
  return 0;
}

void display_present(VBoxDisplay *display) {
  if (display) {
    display->present();
  }
}

void display_clear(VBoxDisplay *display) {
  if (display) {
    display->clear();
  }
}

} /* extern "C" */
